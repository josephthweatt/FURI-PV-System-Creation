1-21-16
-need to tweak equation to get proper sunrise/sunset schedules. Must do this before continuing to the rest of the equations. For future reference, the url of the main resource is:
	http://www.pveducation.org/pvcdrom/properties-of-sunlight/calculation-of-solar-insolation
-oh, and I see that there is a more reliable equation for sunrise/set on that same page. I'll do it tomorrow, I need to sleep.

-woke up, think i figured out the sunrise/set equation. Use this for declination:
	http://www.itacanet.org/the-sun-as-a-source-of-energy/part-3-calculating-solar-angles/#3.1.-Declination-Angle
-Also, divide arccos by 15, make every trig function use degrees, and add the result by one (to account for 12:00 am in the day)

1-27-16
-gave up on making the sunset/rise prediction equation. Just using an API instead. That works, so I'm going to integrate that with the rest of the pveducation equations.

1-29-16
-currently trying to find the solar insolation for a given day. I have the equations all together, which involves calculating air mass, solar insolation, and the length of daylight hours. I linked air mass with the grander solar insolation equation, I am now needing to find out how to use the hours of daylight in an hour to extend the period length of the other equation to match the day.
I think I have the equation working. Was frustrated with tyring to integrate the sunlight hours into the graph, but I think I found something which may render that useless. Pveducation says there is roughly 12 hours of sunlight on average over the year, meaning that taking all daylight hours in a year and dividing them by 365 gives you 12. I will test this tomorrow with the API to see if it is accurate.
On an off note, even if I don't get twelve, I could still use the avg hours to assert that the Id equation can run with one number, as opposed to running itself for each specific day. 

1-30-16
-I was able to show that any area on the earth gets a daily avg of 12 hours of sunlight annually. I'll use that constant of 12 for now to work on the solar insolation equation. I think the formulas needed to predict that must span the length of 12 hours, and to find total solar insolation in a day I would need the area under the curve (integral). The only problem is that the result would entail that all places on earth have the same annual solar insolation. While that might be somewhat true (variations in sea level would likely disprove that hypothesis) I would still have problems in finding what the annual solar insolation IS. 
-The big issue with the solar insolation is with the peak hour. While I've been able to create the span of the daytime hour, I haven't been able to change the peak. The cause of peak change I'm sure I know: the changing of seasons and earth declination, bringing the earth closer to the sun and possibly affecting the air mass.
-I'm going to attempt to turn some of the data points visible on pveducation into graphs using logger pro, hopefully I can get some indication of how their formulas are working. 
	*This did not work as well as I had planned. the slope of this graph was too unfitting for the data.

-Turning in for the night. I think the solar irradiance thing has played out for this week. I'll revisit the problem when I meet with Pan's associate. Till then, I'll spend time think over other aspects of the master problem.

2-3-16 
-Today, I'm going tolook at something called the NREL Solar API, something that might very well predict the weather for me. I'm going to have a look at some of its results and play with its different features, becuase if it does work, it'll save lots of time for me to work with the crux of my research. 
-My main concern with this api will be whether it factors weather interference into its calculations, or if its going to just give me best case scenarios and expects me to work from there. I'll write this down once I find out.

About the API
-------------
Name: PVWatts
Version: 5
site: http://developer.nrel.gov/docs/solar/pvwatts-v5/
Description:NREL's PVWatts calculates the energy production of grid-connected photovoltaic (PV) energy systems. This service estimates the performance of hypothetical residential and small commercial PV installations.

First test case (using SPR-E20-327-COM)
---------------------------------------
-to send out my first calls, I'm going to need to get the following information (all required):

	-address of where I'm setting up the panels
	-system capacity: otherwise known as nominal capacity, nominal power, power rating, etc. It's how much power a solar panel can produce under ideal conditions (my datasheets call this thing nominal power)
	-module type: with selection of std, premium, or thin film. I'll assume the modules are std if it's not mentioned.
	-loses: the percent (as an integer) of energy lost in converting power from DC to AC. I don't know this for my test systems of the bat (something I will need to talk to a professor about later) so I'll assume ten percent loss (10%)
	-array_type: the array type. I'll assume fixed-open rack for right now
	-tilt (set to 0)
	-azimuth: this is the angle of the object with respect to the plane it rests on (earth). 0 degrees is an object aligned directly north, and its angle increases with clockwise pivoting. For the test case, I'll assume it has a 0 degree angle (this variable is currently unneeded, as there is no tilt on the test case module)
	

I compiled all of this into a url and got my data. Here's what came in it:
	* Estimated AC produced monthly (in KWh)
	* Estimated Solar irradiance (in KWh/m^2) on the land
	* Estimated Solar irradiance per day (KWh/m^2/day)
	* Estimated DC produced monthly (in KWh)
	* annual AC generated
	* annual Solar Radiation generated


-the data seems to be alright, nothing too out of the ordinary. However, I would like to be sure of the API's accuracy, and to do this, I'll be comparing PVWatts' results with that of "Real-time prediction models for output power...", the research which had recorded data of a solar panel in Macau, China for a solid year.
-I've gotten the estimated data from my program, but can't seem to find anything from the research paper. I can look into this tomorrow, though I might not be able to find an annual yeild off the paper (maybe try searching for a monthly, or maybe they didn't include it becuase their research focused more on their gaussian models)

2-4-16
-Looking at the research paper, I didn't find the power output in terms of months or the whole year. There was a lot of information about the minutely output, but that's difficult to multiply into months because it does not specify the weather conditions.
-I'm certain that using PVWatts will be the best alternative to creating my own equation. The process has already been thoroughly developed and accounts for more factors than I would have been able to. It uses weather history and tilt, along with the type of panel arrangement, to find what kind of power might be generated from one's system. 
-I've gone through all of PVWatt's cautionary disclaimers (link below) and believe that the problems potentially faced will not come as too great a disadvantage. Furthermore, I've found PVWatts is an acclaimed technology and has the trust of many solar prediction sites.
	PVWatts Cautions: http://rredc.nrel.gov/solar/calculators/pvwatts/interp.html

*Just a reminder, the PVWatts calculator is returning calculations of output PER METERS SQUARED. To make sure I get the real results, I might need to multiply the outputs of the system by their surface size, if the api hasn't already covered this.

-To test the surface changes, I want to  compare it to the information in the link posted below. Here,they say that a square foot of solar panel (ignore specs for right now) is going to generate 30 KW for an entire year. Change this data to meters squared (m^2 = 10.7639 ft^2) and you have the pannel generating 322.917 KW. The macau panel was less than that (211 KW) but still in the lower triple-digits. Lets also keep in mind that the Macau panels had a max output power of 175 Watts, which is below average. Overall, the PVWatts system makes sense, so it'll be used for the duration of the research.	

	Solar Basics: http://www.lightsonsolar.com/solar-basics-kw-and-kwh/

-Now I'm going to Implement a database for PVWatts to take information from. The models inserted from the database all come from one company, Sunpower, at the time of this writing. I'm going to make something in the code that reaches into the db, assigns values as a new system, and makes an API call with that information. I'm thinking later I will be using the DB to create Objects (saved as .ser files) to be manipulated with the API later.

2-7-16 (Also covers work done on 2-6)
-Started implementing the database with the PVWatts program. Everything works so far. PVModels are being stored as objects (PVModelObject.java) and iterated through with a for loop. 


2-9-16
-For today and tomorrow, I'll be trying to get some product types into the database. PVModels.db (I should probably change that name) will hold the tables of all the essential parts needed for a residential solar system. I will not be able to datamine sites for product data, as I am looking for product features essential to the estimation of power output. For example, all inverters in the database must have a specified efficiency, otherwise the PVWatts estimation would be skewed.

2-11-16
-I'm almost finished with the database, I'm waiting right now for a reply from Sai with regards to the wiring and meter tables. I'm also going to add schema information for all of the tables I've created thus far.
-I've finished all of the database and have made a file to make comments on the schema of each table. Unfortunately, I wasn't able to data mine a site as I thought, and had to insert the product information by hand. A copy of this database and the schema notes can be found in the "Product Database" folder. 
About the Database: 
	*all product info was attained through wholesalesolar.com, using their catalog to get important product information. 
	*I tried to store 15 products per type, so 15 solar panels, 15 inverters, etc. Hopefully this will provide a good enough variety for the algorithm to work with.

2-24-16
-Yesterday I created Java objects for each product type listed in PVModels.db. Now I'm going to need an object to pull together these objects to make a full PVSystem. This is going to be the object that I put through the PVWatts API, and the one that will hold the following information: 
	-price
	-power output (monthly and yearly)
	-the names of each product that the user will need to buy
		*additionally, will need to say whether the user will need to buy multiple of the same product (e.g. 4 panels, 4 batteries, 1 inverter, etc.)
	-All of the required system-related PVWatts parameters, like
		*the "loss", or what percent of the energy aquired will be lost (Dr. Sai gave me an equation for this, so I'll use that)
		*array type
		*module type
		*the azimuth angle
			-until the time comes that we can find the possible azimuth's for each user's location, we will assume that the azimuth is the ideal for that location (so: 180 deg if it's north of the equator, 0 deg for south of eq.)
		*tilt (will need a method to optimize the tilt of the panels)
		

-I'm not sure if I want to include this object in the ProductObjects Package or if I should put it in the main Package. For right now, I'll put it in the package, but will take it out if that makes the class too hard to reach for my purposes.

2-16-16
-I've created the first draft of the DBExtraction class yesterday. It serves it's main function (to take info out of the database and convert it to objects) but I'm not sure which features to add and which features ought to be made somewhere else--i.e. the class encasing the algorithms.
-I'm going to figure out these features as I go. My biggest priority is building the algorithms to sort the data. This is going to require more reading, more reviews, and ultimately a master class to handle all of the equations. 

2-17-16
-I'm going to attempt a price sorting algorithm for the price aspect of the software. This will be done in the DBExtraction class (note to self, change the name to express its larger scope as a holder of multiple systems). How my other programs will have acess to these price-organized structure is a bit fuzzy, but I don't have anything I need to do immediately and I want to work on the project before I get to tired (and I want to keep up my current github streak), so its happening tonight!
-I'll organize the price sorting into groups based on products. The collection of these products might need to be stored in subclasses in order for pvsystems to chose which products are viable.
-First I will need to create a way to ship all the data of a product type to another class for cleaner handling


2-18-16
I'm going to need to organize tasks into classes. I have the API into what is currently the main method, when it should be working from another class	

2-19-16
-Starting on class organization. The first thing I want to do is create a class explicitly for using the PVWatts API, and make that class accessible through the FullSystem class
-it has also occured to me that the "monthly AC/DC" in the FullSystem class might need to be ignored for the time being, as implementing it would require an array index of all the months, and that's too complicated for getting things organized
-I've implemented the API manager into the FullSystem class and added an additional subclass into the pvInfoMain class that will give location in either address or coordinates. The api implementation looks pretty good for right now. I think next I will need to work on the productContainer class. I will also needto take some of the methods out of the DBExtract class andput them into their own class (I believe my chart says they go into system management, but I'm not sure. I wrote it all down on the window and now it's night and I can't see it).

2-22-16
-Implementation of the organized model seems to be coming to a head. The only thing I need to do now is to create a way for ProductContainer to work with various ProductObjects and, lastly to debug. After that, I'll start working on algorithm design (and I'll need to see Professor Pan for that).

-I learned that I can make the ProductContainer  capable of accessing object-specific fields using the Field type.
	For example, if I had an "Object" that was cased as a "Panel", and I wanted to get the name of the panel from its Panel object, I could do:
	return (String) productType.getDeclaredField("name").get(products.get(0));
-this would allow Product Container to freely access any datatypes of the objects it currently holds
	* the methods within Products Container will need to throw the IllegalAccessException & the NoSuchFieldException

-Before I go further with the implementation of Fields, I must also recollect what it is I want ProductContainer to do with them. For the next git commit, the class will be able to:
	*organize any comparable field from highest to lowest, or from lowest to highest
	*get field data from various objects (possibly by using a parameter to find the field)
	*return product objects (sometimes in arrays (as in rankings))
-looking at all my product objects, the various datatypes are between String, int, and doulbe (there is one boolean instance with the Racking object, but besides that everything can be organized)

2-23-16
-In preparing to make the sorting algorithm, I looked through the various types of algorithms that could be used. Quicksort seems to be the best for comparison-based sorting with a big O of O(n log(n)). I'll learn how to implement this in java, and then apply it to the hiToLo and loToHi methods
	*some of the string variables might require parsing to attain more detailed info. If parsing is needed, then I will put the method in its respective object and make it public.
-I am going to need 4 variations of the quickSort to access all datatypes in the ProductObjects package. I implemented the first one (the lowToHiString), and am debuging the code now

2-24-16
-I am going to finish up the info processing phase of this project with some standard debugging. The objectives here include:
	1. better cohesion
	2. making the systemCreator easy to access from other classes (while still keeping the sysManager class necessary for handling instances of the FullSystem class)
	3. setting up an area to run the algorithms for deciding which products to use (I'm thinking these could go in the SystemCreator subclass)

3-9-16
-Returning back to the project after a week and a half. Certain projects, midterms, job searches and other things* have kept me from making any changes or advancing the project further, but I intend to work on it for the duration of spring break.
-Today begins the next phase of the research: the algorithm design phase (aka the core of the reasearch project). To begin, I'll create a prototype algorithm for the "Price" objective, which will sort ten viable PV systems based on their affordability. Doing this will allow me to see what additional methods stll need to be included in the code for the algorithms to work. Presently I can think of one method I will be needing (mentioned in the list below), but will think about what other changes could be made as I create my prototype algorithm.

Quick Reminder To Self (IMPORTANT): It seems I have forgotten to include the panel size in my database test case. This is going to be a problem for more reasons than I care to list. I'm going to have to copy over the DB information from the existing db to another db with the same colum, then refactor the code to account for these changes. I will need to do this later tonight.

Additional methods I will need to add (still expanding):
	-be able to store Panel size (X)
	-be able to pass panel size into the PVWatts API portion of the full system (X)
	-be able to use the users desired power output to find the real Panel Span (I'll explain in detail later)
		*this will require the poewr output of a single panel model
	-be able to convert side in feet or inches squared to meters squared (X) 
	-a method (or possibly several) to verify whether two parts are compatible in terms of matching voltage or power. Example) an Inverter cannot have a lower input voltage than the voltage a Panel outputs. 

*To make matters worse, I caught a cold just before the break started. I'm just now recovering from this, but have kept busy in the meantime. Namely, I finished the Codecademy course for Python, which will come in use if I find the time to make a server on my Raspberry Pi, and I made my computer a dualboot system for Windows & Ubuntu.

3-10-16
-Today I added the Dimensions column to the Panels table, as well as a size value to the Panel object. I am now trying to get the size to work with the rest of my code.
-I am changing around the PVWattsManager so that it will be able to accurately know what to do with system size. I found that I was using size to multiply the AC and DC of the system, when it should have been multiplying itself to the poa (plane of array), which is in kWh per m^2. 
